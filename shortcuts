./stop-dev.sh && sleep 3 && ./SIMPLE-START.sh

npm run test:ui
npm run test:run     # Tests einmal ausf√ºhren
npm run test         # Tests im Watch-Mode
npm run test:coverage # Coverage Report

release:
claude.md √ºberpr√ºfen - da steht workflow

Test123
Test12345

/plugin marketplace add anthropics/claude-code

und ich kann immer noch kein mitarbeiter mit 0 stunden und 0 urlaub erstellen. wenn ich auf speichern klicke wird er automatisch mit
  40 stunden und 30 Urlaub gespeichert. erstelle einen plan wie du mit playwright alle funktionen mit user ersellung und bearbeitung
  durchtesten kannst
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ


> ist nun urlaub, krankmeldung , √ºberstundenausgleich und unbezahlter urlaub im backend und frontend perfekt auf das neue individuelle wochenplan
  system ausgerichtet und das alte system mit dem wo die stunden gleichm√§√üig √ºber die woche verteilt werden noch vorhanden? vergleiche es auch mit
  den profiprogrammen 

  gehe unser komplettes system durch und analysiere ob irgendwo unser individuelles wochensystem noch nicht implementiert ist wo es aber sein 
sollte. mache mir einen plan was wir haben und was noch fehlt 


Perfekt! Jetzt kann ich den vollst√§ndigen Plan erstellen:
                                                                                                                                              
‚è∫User approved Claude's plan:
  ‚éø  üèÜ Enterprise-Grade √úberstunden-System: Vollst√§ndiger Plan

     üìö Recherche-Ergebnisse: Wie machen es die Profis?

     ‚úÖ SAP SuccessFactors

     - Time Account System mit separaten Konten
     - Automatische √úbertragung zum Jahreswechsel
     - Konfigurierbare Limits (Max Plus/Minus)

     ‚úÖ Personio

     - √úberstundenkonto mit Buchungen
     - Manuelle oder automatische Minusstunden
     - Jahreswechsel: Vollst√§ndige √úbertragung

     ‚úÖ Deutsches Arbeitsrecht (Arbeitszeitkonto)

     - Kurzzeitkonto: Ausgleich innerhalb 12 Monate (Standard)
     - Langzeitkonto: Mehrj√§hrige Ansparung m√∂glich
     - Limits: 
       - Empfohlen: Max +50h / -20h
       - Mindestlohnempf√§nger: Max 50% der Monatsstunden
       - Leiharbeiter: Max 200h

     ---
     üéØ Unser System: Bereits vorhanden!

     ‚úÖ Was wir schon haben:

     1. work_time_accounts Tabelle (‚úÖ Bereits implementiert!)
     - currentBalance (Aktueller Saldo)
     - maxPlusHours: 50h (Standard)
     - maxMinusHours: -20h (Standard)
     2. Jahreswechsel-Service (‚úÖ Bereits implementiert!)
       - yearEndRolloverService.ts
       - bulkInitializeOvertimeBalancesForNewYear()
       - Automatischer Cron-Job zum 01.01.
     3. √úberstunden-Berechnung (‚úÖ Funktioniert!)
       - overtime_balance Tabelle (monatlich)
       - overtimeService.ts
       - Feiertage werden ber√ºcksichtigt

     ---
     üö® Das Problem: √úberstunden-Ausgleich falsch behandelt

     ‚ùå Aktuell (FALSCH):

     // overtimeService.ts, Zeile 58
     type IN ('sick', 'vacation', 'overtime_comp')  // ‚Üê FEHLER!

     Was passiert:
     - √úberstunden-Ausgleich wird wie Urlaub behandelt
     - Gibt IST-Stunden-Gutschrift (+4h)
     - Sollte aber √úberstunden ABBAUEN (-4h)!

     Beispiel Silvia:
     - Aktuell: +3h (falsch!)
     - Sollte sein: -1h (korrekt!)

     ---
     ‚úÖ Die L√∂sung: Transaction-basiertes System

     Neue Tabelle: overtime_transactions

     CREATE TABLE overtime_transactions (
       id INTEGER PRIMARY KEY AUTOINCREMENT,
       userId INTEGER NOT NULL,
       date TEXT NOT NULL,              -- Buchungsdatum
       type TEXT NOT NULL,               -- 'earned' | 'compensation' | 'correction'
       hours REAL NOT NULL,              -- Stunden (+ oder -)
       description TEXT,                 -- Beschreibung
       referenceType TEXT,               -- 'time_entry' | 'absence' | 'manual'
       referenceId INTEGER,              -- FK zu time_entries oder absence_requests
       createdAt TEXT DEFAULT (datetime('now')),
       createdBy INTEGER,                -- Admin bei manuellen Korrekturen
       FOREIGN KEY (userId) REFERENCES users(id),
       FOREIGN KEY (createdBy) REFERENCES users(id)
     );

     CREATE INDEX idx_overtime_transactions_userId ON overtime_transactions(userId);
     CREATE INDEX idx_overtime_transactions_date ON overtime_transactions(date);
     CREATE INDEX idx_overtime_transactions_type ON overtime_transactions(type);

     ---
     üìä Wie funktioniert das System?

     1Ô∏è‚É£ √úberstunden VERDIENEN (t√§glich, automatisch)

     Nach jeder Zeiterfassung:
     // timeEntryService.ts - nach CREATE/UPDATE/DELETE
     function updateOvertimeTransactions(userId: number, date: string) {
       // Berechne Soll/Ist
       const targetHours = getDailyTargetHours(user, date); // Ber√ºcksichtigt Feiertage!
       const actualHours = getWorkedHours(userId, date);
       const overtime = actualHours - targetHours;

       if (overtime !== 0) {
         // Buchung ins √úberstundenkonto
         db.prepare(`
           INSERT INTO overtime_transactions 
           (userId, date, type, hours, description, referenceType)
           VALUES (?, ?, 'earned', ?, ?, 'time_entry')
         `).run(userId, date, overtime, `Differenz Soll/Ist ${date}`);
       }
     }

     Beispiele:
     - 01.01. (Feiertag): 10.5h - 0h = +10.5h ‚úÖ
     - 07.01. (Mittwoch): 6h - 8h = -2h ‚úÖ
     - 14.01. (Mittwoch): 0h - 8h = -8h ‚úÖ (heute, keine Erfassung!)

     2Ô∏è‚É£ √úberstunden-Ausgleich NEHMEN (bei Genehmigung)

     Wenn Admin √úberstunden-Ausgleich genehmigt:
     // absenceService.ts - beim approve()
     async function approveAbsence(absenceId: number, adminId: number) {
       const absence = getAbsence(absenceId);
       
       // Normale Genehmigung
       db.prepare('UPDATE absence_requests SET status = ? WHERE id = ?')
         .run('approved', absenceId);

       // Wenn √úberstunden-Ausgleich: Konto reduzieren!
       if (absence.type === 'overtime_comp') {
         const hoursToDeduct = calculateAbsenceHours(
           absence.startDate, 
           absence.endDate, 
           user.workSchedule
         );

         // Buchung ins √úberstundenkonto (NEGATIV!)
         db.prepare(`
           INSERT INTO overtime_transactions 
           (userId, date, type, hours, description, referenceType, referenceId)
           VALUES (?, ?, 'compensation', ?, ?, 'absence', ?)
         `).run(
           absence.userId, 
           absence.startDate, 
           -hoursToDeduct, 
           `√úberstunden-Ausgleich ${absence.startDate}-${absence.endDate}`,
           absenceId
         );

         // work_time_accounts aktualisieren
         updateWorkTimeAccountBalance(absence.userId);
       }
     }

     3Ô∏è‚É£ Saldo abrufen

     function getOvertimeBalance(userId: number): number {
       const result = db.prepare(`
         SELECT COALESCE(SUM(hours), 0) as balance
         FROM overtime_transactions
         WHERE userId = ?
       `).get(userId);

       return result.balance;
     }

     ---
     üîÑ Behandlung der Abwesenheitstypen

     ‚úÖ Urlaub / Krankheit (UNVER√ÑNDERT)

     Soll/Ist-Tracking:
       SOLL: 0h (Tag wird nicht gez√§hlt)
       IST:  +8h (Gutschrift wie bisher)
       
     √úberstundenkonto:
       KEINE Buchung (bleibt unver√§ndert)

     ‚úÖ √úberstunden-Ausgleich (NEU!)

     Soll/Ist-Tracking:
       SOLL: 0h (Tag wird nicht gez√§hlt)
       IST:  +4h (Gutschrift wie Urlaub - BLEIBT SO!)
       
     √úberstundenkonto:
       -4h Buchung (separate Transaction!)

     WICHTIG: 
     - overtime_comp bleibt bei sick/vacation in calculateAbsenceCreditsForMonth()
     - ZUS√ÑTZLICH wird √úberstundenkonto reduziert
     - Keine komplizierte Soll/Ist-Logik √§ndern!

     ---
     üéØ Jahreswechsel (bereits implementiert!)

     ‚úÖ Was schon funktioniert:

     1. Automatischer Cron-Job (01.01. 00:00 Uhr)
     // cronService.ts
     cron.schedule('0 0 1 1 *', () => {
       performYearEndRollover(newYear);
     });
     2. √úbertragung √úberstunden
     // overtimeService.ts - bulkInitializeOvertimeBalancesForNewYear()
     const carryover = getYearEndOvertimeBalance(userId, previousYear);
     db.prepare(`
       INSERT INTO overtime_balance 
       (userId, month, carryoverFromPreviousYear)
       VALUES (?, '2026-01', ?)
     `).run(userId, carryover);

     ‚úÖ Was wir anpassen:

     Transaction-System ber√ºcksichtigen:
     // Beim Jahreswechsel: Keine Extra-Logik n√∂tig!
     // Der Saldo aus overtime_transactions bleibt automatisch erhalten:

     SELECT SUM(hours) FROM overtime_transactions WHERE userId = ?
     // ‚Üí Funktioniert √ºber Jahresgrenzen hinweg! ‚úÖ

     Optional: Jahreswechsel-Buchung f√ºr Audit Trail:
     // yearEndRolloverService.ts
     db.prepare(`
       INSERT INTO overtime_transactions 
       (userId, date, type, hours, description, referenceType)
       VALUES (?, '2026-01-01', 'carryover', 0, 'Jahreswechsel 2025‚Üí2026', 'system')
     `).run(userId);

     ---
     üõ°Ô∏è Limits & Validierung (Deutsches Arbeitsrecht)

     Bereits vorhanden:

     work_time_accounts:
       maxPlusHours: 50h   -- Standard-Limit
       maxMinusHours: -20h -- Standard-Limit

     Neue Validierung bei √úberstunden-Ausgleich:

     async function approveOvertimeCompensation(absenceId: number) {
       const absence = getAbsence(absenceId);
       const currentBalance = getOvertimeBalance(absence.userId);
       const hoursToDeduct = calculateAbsenceHours(...);

       // Check: Genug Guthaben?
       if (currentBalance - hoursToDeduct < account.maxMinusHours) {
         throw new Error(
           `Unzureichendes Guthaben. Aktuell: ${currentBalance}h, ` +
           `Nach Ausgleich: ${currentBalance - hoursToDeduct}h, ` +
           `Limit: ${account.maxMinusHours}h`
         );
       }

       // Genehmigung durchf√ºhren...
     }

     ---
     üìã Implementierungsschritte

     Schritt 1: Migration - Tabelle erstellen

     -- migrations/014_overtime_transactions.sql
     CREATE TABLE overtime_transactions (...);
     CREATE INDEX ...;

     Schritt 2: Transaction-Service

     // server/src/services/overtimeTransactionService.ts
     export function recordOvertimeEarned(...)
     export function recordOvertimeCompensation(...)
     export function getOvertimeBalance(...)
     export function getOvertimeHistory(...)

     Schritt 3: Integration in timeEntryService

     // Nach jedem CREATE/UPDATE/DELETE von time_entry
     updateOvertimeTransactions(userId, date);

     Schritt 4: Integration in absenceService

     // Beim approve() von overtime_comp
     recordOvertimeCompensation(...);

     Schritt 5: Historische Daten migrieren

     // scripts/migrateOvertimeToTransactions.ts
     // Alle overtime_balance Eintr√§ge in Transaktionen umwandeln

     Schritt 6: Frontend anpassen

     // Neue Seite: √úberstundenkonto-√úbersicht
     // - Aktueller Saldo
     // - Transaction-Historie (Kontoauszug)
     // - Limits anzeigen

     ---
     ‚è±Ô∏è Zeitaufwand

     | Schritt                      | Aufwand      |
     |------------------------------|--------------|
     | Migration + Tabelle          | 20 Min       |
     | Transaction-Service          | 45 Min       |
     | Integration timeEntryService | 30 Min       |
     | Integration absenceService   | 30 Min       |
     | Historische Migration        | 45 Min       |
     | Frontend √úbersicht           | 60 Min       |
     | Testing                      | 45 Min       |
     | GESAMT                       | ~4.5 Stunden |

     ---
     ‚úÖ Warum ist diese L√∂sung am professionellsten?

     1Ô∏è‚É£ Enterprise-Standard

     - SAP SuccessFactors: "Time Account System"
     - Personio: "√úberstundenkonto mit Transaktionen"
     - Deutsches Arbeitsrecht: "Arbeitszeitkonto-Konzept"

     2Ô∏è‚É£ Single Source of Truth

     - Eine Tabelle (overtime_transactions) f√ºr alle Buchungen
     - Keine komplexe Berechnung aus mehreren Quellen

     3Ô∏è‚É£ Immutable Audit Trail

     - Transaktionen werden nie ge√§ndert, nur hinzugef√ºgt
     - Vollst√§ndige Nachvollziehbarkeit
     - Compliance-konform

     4Ô∏è‚É£ Unabh√§ngig von Soll/Ist

     - Monatliche √úberstunden k√∂nnen falsch sein
     - Konto bleibt korrekt (eigene Transaktionen)
     - Fehlerresistent

     5Ô∏è‚É£ Einfache Logik

     - Saldo = SUM(hours)
     - Keine komplexen Berechnungen
     - Verst√§ndlich f√ºr User

     6Ô∏è‚É£ Jahreswechsel automatisch

     - Kein Extra-Code n√∂tig
     - Transaktionen √ºberschreiten automatisch Jahresgrenzen
     - Bereits implementierter Rollover funktioniert weiter

     7Ô∏è‚É£ Konfigurierbare Limits

     - maxPlusHours / maxMinusHours bereits vorhanden
     - Validierung bei √úberstunden-Ausgleich
     - Deutsches Arbeitsrecht konform

     ---
     üéØ Erwartetes Ergebnis: Silvia Lachner

     √úberstunden-Transaktionen:

     01.01.: +10.5h (10.5h am Feiertag gearbeitet)
     02.01.: -4h    (√úberstunden-Ausgleich)
     07.01.: -2h    (6h statt 8h)
     08.01.: +1h    (9h statt 8h)
     09.01.: +1.5h  (5.5h statt 4h)
     14.01.: -8h    (Heute, keine Zeiterfassung)
     ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
     SALDO: -1h ‚úÖ

     work_time_accounts:

     userId: 18
     currentBalance: -1h
     maxPlusHours: 50h
     maxMinusHours: -20h

     overtime_balance (2026-01):

     SOLL: 32h (ohne Feiertag, mit √úberstunden-Ausgleich als Gutschrift)
     IST:  35h (31h + 4h Gutschrift)
     DIFF: +3h (wird ignoriert, transactions sind f√ºhrend!)

     ---
     üîí Sicherheit & Validierung

     ‚úÖ Database Backup vor Migration‚úÖ Transaction-basierte Migration (all-or-nothing)‚úÖ Rollback-Script vorbereiten‚úÖ Limits validieren bei 
     √úberstunden-Ausgleich‚úÖ Audit Trail f√ºr alle Buchungen‚úÖ Tests f√ºr Edge Cases (Feiertage, Jahreswechsel)

     ---
     ‚úÖ Definition of Done

     - overtime_transactions Tabelle erstellt
     - Transaction-Service implementiert
     - Integration in timeEntryService
     - Integration in absenceService
     - Historische Daten migriert
     - Frontend √úberstundenkonto-Seite
     - Silvia hat -1h (korrekt!)
     - Jahreswechsel funktioniert
     - Limits werden validiert
     - Keine Regression bei Urlaub/Krankheit
  ‚éø
